From:
To:
Date:
Subject: Binary number
The '''binary numeral system''' is a way to write numbers using only two digits: 0 and 1. Because binary only has two digits, it is a Base_(mathematics) 2 number system. Computers work in binary, because it is the simplest way to store information using electricity. A wire can be powered on to represent a 1, or powered off to represent a 0. Large sets of binary numbers can be used by computers to represent other types of information, such as text, songs, or videos. ==Counting in binary== When thinking about binary numbers, it helps to go back and think about how decimal numbers work. A single-digit number can only go from 0 to 9, so another digit is added that counts tens instead of ones. Then another digit is added that counts hundreds, and another that counts thousands, and so on. Each digit's place value is ten times the last digit. Binary follows the same idea. Each digit can only have two values, so each digit's place value is two times the last digit. {| border="1" style="float:right; margin-left:10px" |0|| '''0000''' || 0+0+0+0 |----- |1|| '''0001''' ||0+0+0+1 |----- |2|| '''0010''' ||0+0+2+0 |----- |3|| '''0011''' ||0+0+2+1 |----- | 4 || '''00100''' || 0+0+4+0+0 |----- | 5 || '''00101''' || 0+0+4+0+1 |----- | 6 || '''00110''' || 0+0+4+2+0 |----- | 7 || '''00111''' || 0+0+4+2+1 |----- | 8 || '''01000''' || 0+8+0+0+0 |----- | 9 || '''01001''' || 0+8+0+0+1 |----- | 10 || '''01010''' || 0+8+0+2+0 |----- | 11 || '''01011''' || 0+8+0+2+1 |----- | 12 || '''01100''' || 0+8+4+0+0 |----- | 13 || '''01101''' || 0+8+4+0+1 |----- | 14 || '''01110''' || 0+8+4+2+0 |----- | 15 || '''01111''' || 0+8+4+2+1 |----- | 16 || '''10000''' || 16+0+0+0+0 |----- | 17 || '''10001''' || 16+0+0+0+1 |----- | 18 || '''10010''' || 16+0+0+2+0 |----- | 19 || '''10011''' || 16+0+0+2+1 |----- | 20 || '''10100''' || 16+0+4+0+0 |----- | 21 || '''10101''' || 16+0+4+0+1 |----- | 22 || '''10110''' || 16+0+4+2+0 |----- | 23 || '''10111''' || 16+0+4+2+1 |----- | 24 || '''11000''' || 16+8+0+0+0 |----- | 25 || '''11001''' || 16+8+0+0+1 |----- | 26 || '''11010''' || 16+8+0+2+0 |----- | 27 || '''11011''' || 16+8+0+2+1 |----- | 28 || '''11100''' || 16+8+4+0+0 |----- | 29 || '''11101''' || 16+8+4+0+1 |----- | 30 || '''11110''' || 16+8+4+2+0 |----- |} For example, let's look at the binary number 10110011. The place values that have a 1 are 1, 2, 16, 32, 128. Adding up all those place values gives us 179, so 10110011 in binary is 179 in decimal. For convenience, binary digits (bits, for short) are usually grouped together in two groups of 4 bits. This is 8 bits, or a byte, and is written using the hexadecimal numeral system. This would be shown as 1011 0011 = B3. ==Binary math== The four basic math operations are addition, subtraction, multiplication and division. ===Addition=== Addition in binary can be done like decimal: going from the smallest digit to the biggest, carrying if needed. {| class=wikitable style="text-align: center;" |+ Addition table |- ! + ! 0 ! 1 |- ! 0 | 0 || 1 |- ! 1 | 1 || 10 |} ====Long carry method==== The long carry method is a different way of adding binary numbers. It can be faster than the usual method if one of the numbers has many ones in a row. Adding 1 to a row of 1s results in 1 followed by the same number of 0s. For example, 1111 + 1 = 10000. The long carry method takes advantage of this fact to make addition faster. Long Carry Method 11110011 + 10010101 Highlight every time a 1 is added to a row of 1s 00 + 100010 Treat the rows of 1s as rows of 0s 00 + 100010 Carry the 1s to the next 0s that aren't highlighted long carry 00 + 100010 110001000 final result ===Subtraction=== Subtraction can also be done like decimal: starting from the leftmost digit to the one's digit, borrowing whenever needed. :0 - 0 = 0 :0 - 1 = 1, borrow the 1 :1 - 0 = 1 :1 - 1 = 0 There is also an different method that can be faster, called the two's complement method. ====Two's complement method==== # If the wiktionary:subtrahend has less digits than the wiktionary:minuend, add leading zeroes until they have equal digits. # Flip every digit in the subtrahend. If a digit is a 1, turn it into a 0, and vice versa. # Add 1 to the subtrahend. # The subtraction problem is now an addition problem. Add the two numbers together. # Remove any carry digits from the result. For example, let's do 1101 - 11 using this method. # 11 has less digits than 1101, so we have to add leading zeroes. 11 becomes 0011. # Flip every bit in 0011. The result is 1100. # Add 1 to 1100. The result is 1101. # Add 1101 and 1101. The result is 11010. # 11010 has a carry digit, so we have to get rid of it. The final result is 1010. ===Multiplication=== Binary has a completely trivial multiplication table, because the only digits are 0 and 1. Any number times 0 is 0, and any number times 1 is itself. {| class=wikitable style="text-align: center;" |+ Multiplication table |- ! * ! 0 ! 1 |- ! 0 | 0 || 0 |- ! 1 | 0 || 1 |} As a result, multiplying several-digit numbers is very simple in binary. All you have to do is choose one number as the "anchor", go through its digits, and copy the other number at every digit with a value of 1. Then, add up all the copies when done. For example, here's 1101 * 11. We'll choose 1101 as the anchor. 1101 has a 1 at the one's, four's, and eight's place, so we copy the other number at those places. 0 1 100 1000 11 + 1100 + 11000 = 100111. Therefore, 1101 * 11 = 100111. Doubling a number in binary can be done without any math. If it's a fractional number, move the decimal point one digit to the right. If it's a whole number, add a 0 to the end of the number. * 1101 doubled is 11010. * 1011.01 doubled is 10110.1 Multiplying by four, eight, 16, and so on is just repeated doubling. * 1010 times four = 1010 doubled twice = 101000 * 1110.11 times sixteen = 1110.11 doubled four times = 11101100 ===Division=== Division is again done like decimal, just with some steps removed due to binary's simple nature. For example, here's 100011 / 101. Long division -------- 101 | 100011 Find the smallest part of the dividend greater than or equal to the divisor. Write a 1 over the last digit of that part. This will be the leftmost digit of the answer. 1 -------- | 11 1000 > 101 Now, subtract the divisor from that part. 1 -------- 101 | 11 - 11 remainder Take the next digit of the dividend and bring it down to the remainder. If it's smaller than the divisor, add a 0 to the answer. If it's greater than or equal to the divisor, subtract the divisor from it and add a 1 to the answer. Repeat until the remainder is 0. 1 -------- 101 | 1000 - 101 11 111 > 101. Add a 1. - 101 10 101 = 101. Add a 1. - 101 0 Therefore, 100011 / 101 = 111 in binary. If we convert this to decimal, we get 35 / 5 = 7, which is correct. Like multiplication, dividing a number by 2 can also be done without any math. Move the decimal point one digit to the left, and if there are only 0s after the decimal point, get rid of them. * 1101 halved is 110.1 * 101010 halved is 10101 Dividing by four, eight, 16, and so on is just repeated halving. * 111000 divided by four = 1110 * 1011001 divided by sixteen = 101.1001 ==History== File:Leibniz binary system 1697.jpg by Gottfried Wilhelm Leibniz, 1697.]]File:Leibniz binary system 1703.pngBinary is a numbering system that is a series of 1s and 0s meaning (to the computers) on and off. It is base_(mathematics) two and our number system (decimal) is base ten, where ten numerals are used rather than two. ===John Leslie=== In 1817, John Leslie (a Scottish mathematician) suggested that primitive societies may have evolved counting with objects (like pebbles) before they had even words to describe the total number of objects involved. The next step in the evolution of counting would have been the discovery that this pile of objects could be reduced into two piles of equal measures (leaving either 0 objects left over or just a remainder of 1). This remainder (odd = 1 or even = 0) would then be recorded and one of the piles removed whilst the second pile was then further divided into two sub piles. If you record the remainder left over after the original pile has been divided in two and continue repeating this process; of sub dividing one of the remaining piles into half and then removing one of those piles and continue by subdividing the remaining pile into two piles you will ultimately be left with just either 2 or 3 objects. If you record the remainder left over (odd = 1 or even = 0) at the end of each reduction you will eventually be left with a tally record of 1's and 0's which will be the binary representation of your original pile of objects. So instead of representing your original pile of objects with a repeating number or marks or tokens (which for large numbers could be quite long) you have reduced your pile of objects into more compact binary number. If you need to recover the original number of objects from this summarised binary number it is easy enough to do; by simply starting with the first tally mark and then doubling it and adding one if the next binary number contains a 1 and then continuing the process until the end of the binary number is reached. So, binary counting may be both the oldest and the most modern method of counting. ===Applications=== Binary was invented by many people, but the modern binary number system is credited to Gottfried Leibniz in 1679, a Germany mathematician. Binary has been used in nearly everything electronics; from calculators to supercomputers. Machine code is binary digits. ==Translation== ===Binary to decimal=== To convert a binary number to decimal, just add together the place values of every digit that's a 1. For example, 10101 = 16 + 4 + 1 = 21. ===Decimal to binary=== To convert a decimal number to binary, you can repeatedly divide the number by 2 until you reach 0, writing down the remainder at each step. Then, put all the remainders in a row, from last to first. The resulting number will be your decimal number in binary. For example, here's 58 converted to binary. 58 / 2 = 29 remainder 0 29 / 2 = 14 remainder 1 14 / 2 = 7 remainder 0 7 / 2 = 3 remainder 1 3 / 2 = 1 remainder 1 1 / 2 = 0 remainder 1 Therefore, 58 in decimal is 111010 in binary. == Related pages == * Octal * Hexadecimal * Negative binary numbers * Decimal numbers in binary * Truth value Category:Numbering systems
